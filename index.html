<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#2563eb">
    <title>ArmoireMaline - D√©tection d'outils manquants</title>
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bg: #f8fafc;
            --surface: #ffffff;
            --text: #1e293b;
            --text-light: #64748b;
            --border: #e2e8f0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
        }

        header h1 {
            font-size: 2.2rem;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .subtitle { color: var(--text-light); font-size: 1rem; }

        /* Cards */
        .card {
            background: var(--surface);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }

        .card h3 { margin-bottom: 12px; }
        .card .desc { color: var(--text-light); font-size: 0.9rem; margin-bottom: 16px; }

        .hidden { display: none !important; }

        /* Upload grid */
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Drop zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(37, 99, 235, 0.05);
        }

        .drop-zone.has-image {
            padding: 10px;
        }

        .drop-zone.has-image .drop-content { display: none; }

        .drop-zone img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            display: none;
        }

        .drop-zone.has-image img { display: block; }

        .drop-icon { font-size: 2.5rem; margin-bottom: 8px; }

        .clear-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: none;
            font-size: 1.2rem;
            line-height: 1;
        }

        .drop-zone.has-image .clear-btn { display: block; }

        /* Options */
        .options-section {
            background: var(--bg);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .options-section summary {
            cursor: pointer;
            font-weight: 600;
            padding: 4px 0;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            padding-top: 16px;
        }

        .option-group label {
            font-weight: 500;
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .option-group input[type="range"] { width: 100%; }

        .option-value {
            font-size: 0.85rem;
            color: var(--primary);
            font-weight: 600;
        }

        /* Buttons */
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background: var(--text-light);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .analyze-container {
            text-align: center;
            margin: 24px 0;
        }

        /* Results */
        .results-section {
            display: none;
        }

        .results-section.visible { display: block; }

        .summary-card {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .summary-card.success { background: rgba(16, 185, 129, 0.1); border: 2px solid var(--success); }
        .summary-card.warning { background: rgba(245, 158, 11, 0.1); border: 2px solid var(--warning); }
        .summary-card.danger { background: rgba(239, 68, 68, 0.1); border: 2px solid var(--danger); }

        .summary-icon { font-size: 3rem; }
        .summary-count { text-align: center; }
        .missing-count { font-size: 2.5rem; font-weight: 700; display: block; }
        .missing-label { color: var(--text-light); }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 8px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.95rem;
            color: var(--text-light);
            border-radius: 8px 8px 0 0;
        }

        .tab:hover { color: var(--text); background: var(--bg); }
        .tab.active { color: var(--primary); background: rgba(37, 99, 235, 0.1); font-weight: 600; }

        .tab-pane { display: none; }
        .tab-pane.active { display: block; }

        .result-image {
            max-width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }

        .result-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .result-item {
            text-align: center;
        }

        .result-label {
            display: block;
            margin-bottom: 12px;
            font-weight: 600;
            font-size: 1rem;
            color: var(--text);
        }

        .result-item canvas {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }

        /* Info box */
        .info-box {
            background: rgba(37, 99, 235, 0.1);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            font-size: 0.9rem;
        }

        .info-box strong { color: var(--primary); }

        /* Loading */
        .loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading.visible { display: flex; }

        .spinner {
            width: 60px; height: 60px;
            border: 5px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading p { margin-top: 20px; color: var(--text-light); font-size: 1.1rem; }

        footer {
            text-align: center;
            padding: 24px;
            color: var(--text-light);
            font-size: 0.85rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 { font-size: 1.6rem; }
            .upload-grid { grid-template-columns: 1fr; }
            .result-comparison { grid-template-columns: 1fr; }
            .btn { padding: 12px 20px; font-size: 1rem; width: 100%; }
            .options-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîß ArmoireMaline</h1>
            <p class="subtitle">D√©tection automatique d'outils manquants</p>
        </header>

        <main>
            <!-- Upload Section -->
            <div class="card">
                <div class="info-box">
                    <strong>Comment √ßa marche :</strong> L'application d√©tecte les outils sur la photo de r√©f√©rence,
                    puis v√©rifie s'ils sont toujours pr√©sents sur la photo actuelle.
                </div>

                <div class="upload-grid">
                    <!-- R√©f√©rence -->
                    <div>
                        <h3>üì∏ Photo de r√©f√©rence</h3>
                        <p class="desc">Armoire compl√®te (tous les outils)</p>
                        <div class="drop-zone" id="refDrop">
                            <input type="file" id="refInput" accept="image/*" capture="environment" hidden>
                            <div class="drop-content">
                                <span class="drop-icon">üìÅ</span>
                                <p>Cliquez ou glissez</p>
                            </div>
                            <img id="refPreview" alt="R√©f√©rence">
                            <button class="clear-btn" id="clearRef">√ó</button>
                        </div>
                    </div>

                    <!-- Actuelle -->
                    <div>
                        <h3>üì∑ Photo actuelle</h3>
                        <p class="desc">Armoire √† v√©rifier</p>
                        <div class="drop-zone" id="curDrop">
                            <input type="file" id="curInput" accept="image/*" capture="environment" hidden>
                            <div class="drop-content">
                                <span class="drop-icon">üìÅ</span>
                                <p>Cliquez ou glissez</p>
                            </div>
                            <img id="curPreview" alt="Actuelle">
                            <button class="clear-btn" id="clearCur">√ó</button>
                        </div>
                    </div>
                </div>

                <!-- Options -->
                <details class="options-section" open>
                    <summary>‚öôÔ∏è Options de d√©tection</summary>
                    <div class="options-grid">
                        <div class="option-group">
                            <label>Sensibilit√© : <span class="option-value" id="sensitivityVal">Moyenne</span></label>
                            <input type="range" id="sensitivity" min="1" max="5" value="3">
                        </div>
                        <div class="option-group">
                            <label>Taille min des outils : <span class="option-value" id="minSizeVal">Moyenne</span></label>
                            <input type="range" id="minSize" min="1" max="5" value="3">
                        </div>
                    </div>
                </details>

                <div class="analyze-container">
                    <button class="btn btn-primary" id="analyzeBtn" disabled>
                        üîç Analyser les diff√©rences
                    </button>
                </div>
            </div>

            <!-- Results Section -->
            <section class="card results-section" id="resultsSection">
                <h3>üìä R√©sultats de l'analyse</h3>

                <div class="summary-card" id="summary">
                    <div class="summary-icon" id="summaryIcon">‚úÖ</div>
                    <div class="summary-count">
                        <span class="missing-count" id="missingCount">0</span>
                        <span class="missing-label">outil(s) manquant(s) sur <span id="totalTools">0</span> d√©tect√©(s)</span>
                    </div>
                </div>

                <div class="result-comparison">
                    <div class="result-item">
                        <span class="result-label">üì∏ R√©f√©rence (outils d√©tect√©s)</span>
                        <canvas id="refToolsCanvas" class="result-image"></canvas>
                    </div>
                    <div class="result-item">
                        <span class="result-label">üì∑ Actuelle (outils manquants en rouge)</span>
                        <canvas id="resultCanvas" class="result-image"></canvas>
                    </div>
                </div>
            </section>
        </main>

        <footer>
            <p>ArmoireMaline v3.0 - D√©tection intelligente d'outils manquants</p>
        </footer>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p id="loadingText">Analyse en cours...</p>
    </div>

    <script>
        // √âtat
        let refImage = null;
        let curImage = null;

        // √âl√©ments DOM
        const els = {
            refDrop: document.getElementById('refDrop'),
            curDrop: document.getElementById('curDrop'),
            refInput: document.getElementById('refInput'),
            curInput: document.getElementById('curInput'),
            refPreview: document.getElementById('refPreview'),
            curPreview: document.getElementById('curPreview'),
            clearRef: document.getElementById('clearRef'),
            clearCur: document.getElementById('clearCur'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            sensitivity: document.getElementById('sensitivity'),
            sensitivityVal: document.getElementById('sensitivityVal'),
            minSize: document.getElementById('minSize'),
            minSizeVal: document.getElementById('minSizeVal'),
            resultsSection: document.getElementById('resultsSection'),
            summary: document.getElementById('summary'),
            summaryIcon: document.getElementById('summaryIcon'),
            missingCount: document.getElementById('missingCount'),
            totalTools: document.getElementById('totalTools'),
            resultCanvas: document.getElementById('resultCanvas'),
            refToolsCanvas: document.getElementById('refToolsCanvas'),
            loading: document.getElementById('loading'),
            loadingText: document.getElementById('loadingText')
        };

        // Setup drop zones
        function setupDropZone(dropEl, inputEl, previewEl, clearBtn, isRef) {
            dropEl.addEventListener('click', (e) => {
                if (e.target !== clearBtn) inputEl.click();
            });

            dropEl.addEventListener('dragover', e => {
                e.preventDefault();
                dropEl.classList.add('dragover');
            });

            dropEl.addEventListener('dragleave', () => dropEl.classList.remove('dragover'));

            dropEl.addEventListener('drop', e => {
                e.preventDefault();
                dropEl.classList.remove('dragover');
                if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0], previewEl, dropEl, isRef);
            });

            inputEl.addEventListener('change', e => {
                if (e.target.files[0]) loadImage(e.target.files[0], previewEl, dropEl, isRef);
            });

            clearBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                previewEl.src = '';
                dropEl.classList.remove('has-image');
                inputEl.value = '';
                if (isRef) refImage = null;
                else curImage = null;
                updateAnalyzeBtn();
                els.resultsSection.classList.remove('visible');
            });
        }

        function loadImage(file, previewEl, dropEl, isRef) {
            const reader = new FileReader();
            reader.onload = e => {
                previewEl.src = e.target.result;
                dropEl.classList.add('has-image');
                if (isRef) refImage = e.target.result;
                else curImage = e.target.result;
                updateAnalyzeBtn();
            };
            reader.readAsDataURL(file);
        }

        function updateAnalyzeBtn() {
            els.analyzeBtn.disabled = !(refImage && curImage);
        }

        // Options labels
        const sensitivityLabels = ['Tr√®s basse', 'Basse', 'Moyenne', 'Haute', 'Tr√®s haute'];
        const minSizeLabels = ['Tr√®s petit', 'Petit', 'Moyen', 'Grand', 'Tr√®s grand'];

        els.sensitivity.addEventListener('input', e => {
            els.sensitivityVal.textContent = sensitivityLabels[e.target.value - 1];
        });

        els.minSize.addEventListener('input', e => {
            els.minSizeVal.textContent = minSizeLabels[e.target.value - 1];
        });

        // Tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
            });
        });

        // Analyze
        els.analyzeBtn.addEventListener('click', analyze);

        async function analyze() {
            els.loading.classList.add('visible');
            els.loadingText.textContent = 'Chargement des images...';
            await sleep(50);

            try {
                const sensitivityLevel = parseInt(els.sensitivity.value);
                const minSizeLevel = parseInt(els.minSize.value);

                // Charger les images
                const refImg = await loadImageAsync(refImage);
                const curImg = await loadImageAsync(curImage);

                const width = refImg.width;
                const height = refImg.height;

                // Cr√©er les canvas
                const refCanvas = createCanvas(width, height);
                const curCanvas = createCanvas(width, height);

                const refCtx = refCanvas.getContext('2d');
                const curCtx = curCanvas.getContext('2d');

                refCtx.drawImage(refImg, 0, 0);
                curCtx.drawImage(curImg, 0, 0, width, height);

                const refData = refCtx.getImageData(0, 0, width, height);
                const curData = curCtx.getImageData(0, 0, width, height);

                // √âTAPE 1: D√©tecter le fond (panneau perfor√© bleu)
                els.loadingText.textContent = 'D√©tection du fond...';
                await sleep(50);
                const { mask: backgroundMask, bgColors } = detectBackground(refData, width, height);

                // √âTAPE 2: D√©tecter les outils sur l'image de r√©f√©rence (tout ce qui n'est pas le fond)
                els.loadingText.textContent = 'D√©tection des outils...';
                await sleep(50);
                const toolsMask = detectTools(refData, backgroundMask, width, height);

                // √âTAPE 3: Nettoyer et trouver les r√©gions d'outils
                const minAreas = [300, 600, 1200, 2500, 5000]; // Valeurs r√©duites pour d√©tecter plus d'outils
                const minArea = minAreas[minSizeLevel - 1];

                const cleanedMask = cleanToolsMask(toolsMask, width, height, minSizeLevel);
                const toolRegions = findToolRegions(cleanedMask, width, height, minArea);

                // √âTAPE 4: V√©rifier quels outils sont manquants
                els.loadingText.textContent = 'V√©rification des outils manquants...';
                await sleep(50);

                const thresholds = [10, 18, 28, 40, 55]; // Seuils plus bas pour √™tre plus sensible
                const threshold = thresholds[sensitivityLevel - 1];

                const results = checkMissingTools(toolRegions, refData, curData, width, height, threshold, bgColors);

                // Afficher les r√©sultats
                displayResults(results, refImg, curImg, width, height, toolRegions);

            } catch (error) {
                console.error('Erreur:', error);
                alert('Erreur: ' + error.message);
            }

            els.loading.classList.remove('visible');
        }

        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        function loadImageAsync(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function createCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        }

        // D√©tecter le fond et les √©l√©ments neutres (gris/blanc/beige)
        function detectBackground(imageData, width, height) {
            const data = imageData.data;
            const mask = new Uint8Array(width * height);
            const bgColors = [];

            // Marquer comme fond : gris, blanc, beige, et couleurs peu satur√©es
            for (let i = 0; i < width * height; i++) {
                const idx = i * 4;
                const r = data[idx];
                const g = data[idx + 1];
                const b = data[idx + 2];

                // Calculer la saturation (diff√©rence entre max et min des canaux)
                const maxC = Math.max(r, g, b);
                const minC = Math.min(r, g, b);
                const saturation = maxC - minC;

                // Luminosit√© moyenne
                const brightness = (r + g + b) / 3;

                // Un pixel est consid√©r√© comme "fond/structure" si :
                // - Faible saturation (gris, blanc, beige) = pas un outil color√©
                // - OU tr√®s clair (blanc, reflets)
                // - OU tr√®s sombre (ombres)
                const isNeutral = saturation < 40; // Peu de couleur
                const isVeryBright = brightness > 220;
                const isVeryDark = brightness < 30;

                mask[i] = (isNeutral || isVeryBright || isVeryDark) ? 255 : 0;
            }

            // Collecter quelques couleurs de fond typiques pour la comparaison
            bgColors.push({ r: 180, g: 180, b: 180 }); // Gris clair
            bgColors.push({ r: 150, g: 150, b: 150 }); // Gris moyen
            bgColors.push({ r: 200, g: 200, b: 200 }); // Gris tr√®s clair
            bgColors.push({ r: 220, g: 220, b: 220 }); // Presque blanc

            return { mask, bgColors };
        }

        // D√©tecter les outils (pixels qui ne sont pas le fond)
        function detectTools(imageData, backgroundMask, width, height) {
            const mask = new Uint8Array(width * height);

            for (let i = 0; i < width * height; i++) {
                // Un outil = pas le fond
                mask[i] = backgroundMask[i] === 0 ? 255 : 0;
            }

            return mask;
        }

        // Nettoyer le masque des outils
        function cleanToolsMask(mask, width, height, sizeLevel) {
            // Taille du kernel pour l'√©rosion/dilatation
            const kernelSizes = [2, 3, 4, 5, 6];
            const kernelSize = kernelSizes[sizeLevel - 1];
            const half = kernelSize;

            // √ârosion forte pour supprimer le bruit et les petits √©l√©ments
            let eroded = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let count = 0;
                    let total = 0;
                    for (let ky = -half; ky <= half; ky++) {
                        for (let kx = -half; kx <= half; kx++) {
                            total++;
                            if (mask[(y + ky) * width + (x + kx)] === 255) {
                                count++;
                            }
                        }
                    }
                    // Au moins 70% des pixels doivent √™tre blancs
                    eroded[y * width + x] = (count / total > 0.7) ? 255 : 0;
                }
            }

            // Dilatation pour restaurer la taille
            let dilated = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let anyWhite = false;
                    for (let ky = -half; ky <= half && !anyWhite; ky++) {
                        for (let kx = -half; kx <= half && !anyWhite; kx++) {
                            if (eroded[(y + ky) * width + (x + kx)] === 255) {
                                anyWhite = true;
                            }
                        }
                    }
                    dilated[y * width + x] = anyWhite ? 255 : 0;
                }
            }

            // Deuxi√®me dilatation
            let result = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let anyWhite = false;
                    for (let ky = -half; ky <= half && !anyWhite; ky++) {
                        for (let kx = -half; kx <= half && !anyWhite; kx++) {
                            if (dilated[(y + ky) * width + (x + kx)] === 255) {
                                anyWhite = true;
                            }
                        }
                    }
                    result[y * width + x] = anyWhite ? 255 : 0;
                }
            }

            return result;
        }

        // Trouver les r√©gions d'outils
        function findToolRegions(mask, width, height, minArea) {
            const visited = new Uint8Array(width * height);
            const regions = [];

            // Calculer la taille minimale pour exclure les trous du panneau
            // Les trous sont g√©n√©ralement petits et circulaires
            const minDimension = 25; // Taille minimale pour un outil
            const maxHoleArea = 1500; // Les trous sont plus petits que √ßa

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (mask[idx] === 255 && !visited[idx]) {
                        const region = floodFill(mask, visited, x, y, width, height);
                        const box = region.boundingBox;

                        // Filtrer les petits trous du panneau perfor√©
                        // Les trous sont g√©n√©ralement circulaires (ratio proche de 1) et petits
                        const aspectRatio = Math.max(box.width, box.height) / (Math.min(box.width, box.height) + 1);
                        const fillRatio = region.area / (box.width * box.height);
                        const isCircular = aspectRatio < 1.8 && fillRatio > 0.5;
                        const isSmallHole = region.area < maxHoleArea && isCircular;

                        // Un outil doit √™tre assez grand et pas un petit trou circulaire
                        if (region.area >= minArea && !isSmallHole) {
                            // V√©rifier que c'est bien un outil (pas trop petit)
                            if (box.width >= minDimension || box.height >= minDimension) {
                                // Filtrer les formes trop fines ou √©tranges
                                if (aspectRatio < 20 && fillRatio > 0.08) {
                                    regions.push(region);
                                }
                            }
                        }
                    }
                }
            }

            return regions;
        }

        function floodFill(mask, visited, startX, startY, width, height) {
            const region = {
                pixels: [],
                minX: startX, maxX: startX,
                minY: startY, maxY: startY,
                area: 0
            };

            const queue = [{x: startX, y: startY}];
            visited[startY * width + startX] = 1;

            while (queue.length > 0) {
                const p = queue.shift();
                region.pixels.push(p);
                region.minX = Math.min(region.minX, p.x);
                region.maxX = Math.max(region.maxX, p.x);
                region.minY = Math.min(region.minY, p.y);
                region.maxY = Math.max(region.maxY, p.y);

                const neighbors = [
                    {x: p.x - 1, y: p.y},
                    {x: p.x + 1, y: p.y},
                    {x: p.x, y: p.y - 1},
                    {x: p.x, y: p.y + 1}
                ];

                for (const n of neighbors) {
                    if (n.x >= 0 && n.x < width && n.y >= 0 && n.y < height) {
                        const nIdx = n.y * width + n.x;
                        if (mask[nIdx] === 255 && !visited[nIdx]) {
                            visited[nIdx] = 1;
                            queue.push(n);
                        }
                    }
                }
            }

            region.area = region.pixels.length;
            region.boundingBox = {
                x: region.minX,
                y: region.minY,
                width: region.maxX - region.minX + 1,
                height: region.maxY - region.minY + 1
            };

            return region;
        }

        // V√©rifier quels outils sont manquants
        function checkMissingTools(toolRegions, refData, curData, width, height, threshold, bgColors) {
            const refPx = refData.data;
            const curPx = curData.data;
            const results = [];

            for (const region of toolRegions) {
                let sampleCount = 0;
                let refColoredPixels = 0; // Pixels color√©s dans la r√©f√©rence
                let curColoredPixels = 0; // Pixels color√©s dans l'image actuelle
                let totalColorDiff = 0;   // Diff√©rence totale de couleur

                // √âchantillonner les pixels de la r√©gion
                for (const p of region.pixels) {
                    // √âchantillonner pour la performance
                    if (region.pixels.length > 500 && Math.random() > 0.6) continue;

                    const idx = (p.y * width + p.x) * 4;

                    const refR = refPx[idx];
                    const refG = refPx[idx + 1];
                    const refB = refPx[idx + 2];

                    const curR = curPx[idx];
                    const curG = curPx[idx + 1];
                    const curB = curPx[idx + 2];

                    sampleCount++;

                    // V√©rifier si color√© dans la r√©f√©rence
                    const refSat = Math.max(refR, refG, refB) - Math.min(refR, refG, refB);
                    if (refSat > 30) refColoredPixels++;

                    // V√©rifier si color√© dans l'actuelle
                    const curSat = Math.max(curR, curG, curB) - Math.min(curR, curG, curB);
                    if (curSat > 30) curColoredPixels++;

                    // Calculer la diff√©rence de couleur
                    const colorDiff = Math.abs(refR - curR) + Math.abs(refG - curG) + Math.abs(refB - curB);
                    totalColorDiff += colorDiff;
                }

                const refColoredRatio = sampleCount > 0 ? refColoredPixels / sampleCount : 0;
                const curColoredRatio = sampleCount > 0 ? curColoredPixels / sampleCount : 0;
                const avgColorDiff = sampleCount > 0 ? totalColorDiff / sampleCount : 0;

                // Un outil est MANQUANT si :
                // 1. Il y avait des pixels color√©s dans la r√©f√©rence (c'est bien un outil)
                // 2. ET il y a beaucoup moins de pixels color√©s maintenant OU grande diff√©rence de couleur
                const wasColoredTool = refColoredRatio > 0.15;
                const colorDisappeared = curColoredRatio < refColoredRatio * 0.5; // Plus de 50% des couleurs ont disparu
                const bigColorChange = avgColorDiff > 60;

                const isMissing = wasColoredTool && (colorDisappeared || (bigColorChange && curColoredRatio < 0.3));

                console.log(`R√©gion: refColored=${refColoredRatio.toFixed(2)}, curColored=${curColoredRatio.toFixed(2)}, avgDiff=${avgColorDiff.toFixed(0)}, missing=${isMissing}`);

                results.push({
                    region: region,
                    refColoredRatio: refColoredRatio,
                    curColoredRatio: curColoredRatio,
                    avgColorDiff: avgColorDiff,
                    isMissing: isMissing
                });
            }

            return results;
        }

        // Afficher les r√©sultats
        function displayResults(results, refImg, curImg, width, height, toolRegions) {
            const missingTools = results.filter(r => r.isMissing);
            const missingCount = missingTools.length;
            const totalTools = results.length;

            // R√©sum√©
            els.missingCount.textContent = missingCount;
            els.totalTools.textContent = totalTools;
            els.summary.className = 'summary-card';

            if (missingCount === 0) {
                els.summary.classList.add('success');
                els.summaryIcon.textContent = '‚úÖ';
            } else if (missingCount <= 3) {
                els.summary.classList.add('warning');
                els.summaryIcon.textContent = '‚ö†Ô∏è';
            } else {
                els.summary.classList.add('danger');
                els.summaryIcon.textContent = 'üö®';
            }

            // Image r√©sultat (photo actuelle avec outils manquants entour√©s)
            els.resultCanvas.width = width;
            els.resultCanvas.height = height;
            const ctx = els.resultCanvas.getContext('2d');
            ctx.drawImage(curImg, 0, 0, width, height);

            // Dessiner les outils manquants en rouge
            let missingIndex = 0;
            for (const result of results) {
                if (result.isMissing) {
                    missingIndex++;
                    const box = result.region.boundingBox;

                    // Fond semi-transparent rouge
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
                    ctx.fillRect(box.x, box.y, box.width, box.height);

                    // Bordure rouge √©paisse
                    ctx.strokeStyle = '#dc2626';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);

                    // Num√©ro
                    ctx.fillStyle = '#dc2626';
                    ctx.font = 'bold 24px sans-serif';
                    ctx.fillText(`${missingIndex}`, box.x + 8, box.y + 28);
                }
            }

            // Image avec tous les outils d√©tect√©s sur la r√©f√©rence
            els.refToolsCanvas.width = width;
            els.refToolsCanvas.height = height;
            const refCtx = els.refToolsCanvas.getContext('2d');
            refCtx.drawImage(refImg, 0, 0);

            // Dessiner tous les outils d√©tect√©s
            results.forEach((result, index) => {
                const box = result.region.boundingBox;

                if (result.isMissing) {
                    refCtx.strokeStyle = '#dc2626'; // Rouge pour manquant
                    refCtx.fillStyle = 'rgba(239, 68, 68, 0.3)';
                } else {
                    refCtx.strokeStyle = '#16a34a'; // Vert pour pr√©sent
                    refCtx.fillStyle = 'rgba(22, 163, 74, 0.2)';
                }

                refCtx.lineWidth = 3;
                refCtx.fillRect(box.x, box.y, box.width, box.height);
                refCtx.strokeRect(box.x, box.y, box.width, box.height);

                // Num√©ro
                refCtx.fillStyle = result.isMissing ? '#dc2626' : '#16a34a';
                refCtx.font = 'bold 16px sans-serif';
                refCtx.fillText(`${index + 1}`, box.x + 5, box.y + 18);
            });

            // Afficher
            els.resultsSection.classList.add('visible');
            els.resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        // Initialisation
        setupDropZone(els.refDrop, els.refInput, els.refPreview, els.clearRef, true);
        setupDropZone(els.curDrop, els.curInput, els.curPreview, els.clearCur, false);
    </script>
</body>
</html>
