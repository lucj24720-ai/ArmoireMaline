<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#2563eb">
    <title>ArmoireMaline - D√©tection d'outils manquants</title>
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bg: #f8fafc;
            --surface: #ffffff;
            --text: #1e293b;
            --text-light: #64748b;
            --border: #e2e8f0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
        }

        header h1 {
            font-size: 2.2rem;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .subtitle { color: var(--text-light); font-size: 1rem; }

        /* Cards */
        .card {
            background: var(--surface);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }

        .card h3 { margin-bottom: 12px; }
        .card .desc { color: var(--text-light); font-size: 0.9rem; margin-bottom: 16px; }

        .hidden { display: none !important; }

        /* Upload grid */
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Drop zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--primary);
            background: rgba(37, 99, 235, 0.05);
        }

        .drop-zone.has-image {
            padding: 10px;
        }

        .drop-zone.has-image .drop-content { display: none; }

        .drop-zone img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            display: none;
        }

        .drop-zone.has-image img { display: block; }

        .drop-icon { font-size: 2.5rem; margin-bottom: 8px; }

        .clear-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: none;
            font-size: 1.2rem;
            line-height: 1;
        }

        .drop-zone.has-image .clear-btn { display: block; }

        /* Options */
        .options-section {
            background: var(--bg);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .options-section summary {
            cursor: pointer;
            font-weight: 600;
            padding: 4px 0;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            padding-top: 16px;
        }

        .option-group label {
            font-weight: 500;
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .option-group input[type="range"] { width: 100%; }

        .option-value {
            font-size: 0.85rem;
            color: var(--primary);
            font-weight: 600;
        }

        /* Buttons */
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background: var(--text-light);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .analyze-container {
            text-align: center;
            margin: 24px 0;
        }

        /* Results */
        .results-section {
            display: none;
        }

        .results-section.visible { display: block; }

        .summary-card {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .summary-card.success { background: rgba(16, 185, 129, 0.1); border: 2px solid var(--success); }
        .summary-card.warning { background: rgba(245, 158, 11, 0.1); border: 2px solid var(--warning); }
        .summary-card.danger { background: rgba(239, 68, 68, 0.1); border: 2px solid var(--danger); }

        .summary-icon { font-size: 3rem; }
        .missing-count { font-size: 2.5rem; font-weight: 700; }
        .missing-label { color: var(--text-light); display: block; }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }

        .tab {
            padding: 8px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.95rem;
            color: var(--text-light);
            border-radius: 8px 8px 0 0;
        }

        .tab:hover { color: var(--text); background: var(--bg); }
        .tab.active { color: var(--primary); background: rgba(37, 99, 235, 0.1); font-weight: 600; }

        .tab-pane { display: none; }
        .tab-pane.active { display: block; }

        .result-image {
            max-width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .comparison-item { text-align: center; }
        .comparison-item span {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-light);
        }
        .comparison-item img {
            width: 100%;
            border-radius: 8px;
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading.visible { display: flex; }

        .spinner {
            width: 60px; height: 60px;
            border: 5px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading p { margin-top: 20px; color: var(--text-light); font-size: 1.1rem; }

        footer {
            text-align: center;
            padding: 24px;
            color: var(--text-light);
            font-size: 0.85rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 { font-size: 1.6rem; }
            .upload-grid { grid-template-columns: 1fr; }
            .comparison-grid { grid-template-columns: 1fr; }
            .btn { padding: 12px 20px; font-size: 1rem; width: 100%; }
            .options-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîß ArmoireMaline</h1>
            <p class="subtitle">D√©tection automatique d'outils manquants</p>
        </header>

        <main>
            <!-- Upload Section -->
            <div class="card">
                <div class="upload-grid">
                    <!-- R√©f√©rence -->
                    <div>
                        <h3>üì∏ Photo de r√©f√©rence</h3>
                        <p class="desc">Armoire compl√®te (tous les outils)</p>
                        <div class="drop-zone" id="refDrop">
                            <input type="file" id="refInput" accept="image/*" capture="environment" hidden>
                            <div class="drop-content">
                                <span class="drop-icon">üìÅ</span>
                                <p>Cliquez ou glissez</p>
                            </div>
                            <img id="refPreview" alt="R√©f√©rence">
                            <button class="clear-btn" id="clearRef">√ó</button>
                        </div>
                    </div>

                    <!-- Actuelle -->
                    <div>
                        <h3>üì∑ Photo actuelle</h3>
                        <p class="desc">Armoire √† v√©rifier</p>
                        <div class="drop-zone" id="curDrop">
                            <input type="file" id="curInput" accept="image/*" capture="environment" hidden>
                            <div class="drop-content">
                                <span class="drop-icon">üìÅ</span>
                                <p>Cliquez ou glissez</p>
                            </div>
                            <img id="curPreview" alt="Actuelle">
                            <button class="clear-btn" id="clearCur">√ó</button>
                        </div>
                    </div>
                </div>

                <!-- Options -->
                <details class="options-section">
                    <summary>‚öôÔ∏è Options de d√©tection</summary>
                    <div class="options-grid">
                        <div class="option-group">
                            <label>Sensibilit√© : <span class="option-value" id="sensitivityVal">Moyenne</span></label>
                            <input type="range" id="sensitivity" min="1" max="5" value="3">
                        </div>
                        <div class="option-group">
                            <label>Taille minimum : <span class="option-value" id="minSizeVal">Moyenne</span></label>
                            <input type="range" id="minSize" min="1" max="5" value="3">
                        </div>
                    </div>
                </details>

                <div class="analyze-container">
                    <button class="btn btn-primary" id="analyzeBtn" disabled>
                        üîç Analyser les diff√©rences
                    </button>
                </div>
            </div>

            <!-- Results Section -->
            <section class="card results-section" id="resultsSection">
                <h3>üìä R√©sultats de l'analyse</h3>

                <div class="summary-card" id="summary">
                    <div class="summary-icon" id="summaryIcon">‚úÖ</div>
                    <div>
                        <span class="missing-count" id="missingCount">0</span>
                        <span class="missing-label">outil(s) manquant(s) d√©tect√©(s)</span>
                    </div>
                </div>

                <div class="tabs">
                    <button class="tab active" data-tab="result">R√©sultat</button>
                    <button class="tab" data-tab="diff">Diff√©rences</button>
                    <button class="tab" data-tab="compare">Comparaison</button>
                </div>

                <div class="tab-pane active" id="tab-result">
                    <canvas id="resultCanvas" class="result-image"></canvas>
                </div>
                <div class="tab-pane" id="tab-diff">
                    <canvas id="diffCanvas" class="result-image"></canvas>
                </div>
                <div class="tab-pane" id="tab-compare">
                    <div class="comparison-grid">
                        <div class="comparison-item">
                            <span>R√©f√©rence</span>
                            <img id="compareRef" alt="R√©f√©rence">
                        </div>
                        <div class="comparison-item">
                            <span>Actuelle</span>
                            <img id="compareCur" alt="Actuelle">
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <footer>
            <p>ArmoireMaline v2.0 - D√©tection intelligente d'outils manquants</p>
        </footer>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>Analyse en cours...</p>
    </div>

    <script>
        // √âtat
        let refImage = null;
        let curImage = null;

        // √âl√©ments DOM
        const els = {
            refDrop: document.getElementById('refDrop'),
            curDrop: document.getElementById('curDrop'),
            refInput: document.getElementById('refInput'),
            curInput: document.getElementById('curInput'),
            refPreview: document.getElementById('refPreview'),
            curPreview: document.getElementById('curPreview'),
            clearRef: document.getElementById('clearRef'),
            clearCur: document.getElementById('clearCur'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            sensitivity: document.getElementById('sensitivity'),
            sensitivityVal: document.getElementById('sensitivityVal'),
            minSize: document.getElementById('minSize'),
            minSizeVal: document.getElementById('minSizeVal'),
            resultsSection: document.getElementById('resultsSection'),
            summary: document.getElementById('summary'),
            summaryIcon: document.getElementById('summaryIcon'),
            missingCount: document.getElementById('missingCount'),
            resultCanvas: document.getElementById('resultCanvas'),
            diffCanvas: document.getElementById('diffCanvas'),
            compareRef: document.getElementById('compareRef'),
            compareCur: document.getElementById('compareCur'),
            loading: document.getElementById('loading')
        };

        // Setup drop zones
        function setupDropZone(dropEl, inputEl, previewEl, clearBtn, isRef) {
            dropEl.addEventListener('click', (e) => {
                if (e.target !== clearBtn) inputEl.click();
            });

            dropEl.addEventListener('dragover', e => {
                e.preventDefault();
                dropEl.classList.add('dragover');
            });

            dropEl.addEventListener('dragleave', () => dropEl.classList.remove('dragover'));

            dropEl.addEventListener('drop', e => {
                e.preventDefault();
                dropEl.classList.remove('dragover');
                if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0], previewEl, dropEl, isRef);
            });

            inputEl.addEventListener('change', e => {
                if (e.target.files[0]) loadImage(e.target.files[0], previewEl, dropEl, isRef);
            });

            clearBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                previewEl.src = '';
                dropEl.classList.remove('has-image');
                inputEl.value = '';
                if (isRef) refImage = null;
                else curImage = null;
                updateAnalyzeBtn();
                els.resultsSection.classList.remove('visible');
            });
        }

        function loadImage(file, previewEl, dropEl, isRef) {
            const reader = new FileReader();
            reader.onload = e => {
                previewEl.src = e.target.result;
                dropEl.classList.add('has-image');
                if (isRef) refImage = e.target.result;
                else curImage = e.target.result;
                updateAnalyzeBtn();
            };
            reader.readAsDataURL(file);
        }

        function updateAnalyzeBtn() {
            els.analyzeBtn.disabled = !(refImage && curImage);
        }

        // Options labels
        const sensitivityLabels = ['Tr√®s basse', 'Basse', 'Moyenne', 'Haute', 'Tr√®s haute'];
        const minSizeLabels = ['Tr√®s petit', 'Petit', 'Moyen', 'Grand', 'Tr√®s grand'];

        els.sensitivity.addEventListener('input', e => {
            els.sensitivityVal.textContent = sensitivityLabels[e.target.value - 1];
        });

        els.minSize.addEventListener('input', e => {
            els.minSizeVal.textContent = minSizeLabels[e.target.value - 1];
        });

        // Tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
            });
        });

        // Analyze
        els.analyzeBtn.addEventListener('click', analyze);

        async function analyze() {
            els.loading.classList.add('visible');
            await new Promise(r => setTimeout(r, 50));

            try {
                const sensitivity = parseInt(els.sensitivity.value);
                const minSizeLevel = parseInt(els.minSize.value);

                // Param√®tres bas√©s sur les sliders
                // Sensibilit√©: seuil de diff√©rence (plus haut = moins sensible)
                const thresholds = [20, 30, 40, 55, 70];
                const threshold = thresholds[sensitivity - 1];

                // Taille minimum en pixels¬≤ (plus l'outil est gros, plus la valeur est haute)
                const minAreas = [1000, 2500, 5000, 10000, 20000];
                const minArea = minAreas[minSizeLevel - 1];

                // Charger les images
                const refImg = await loadImageAsync(refImage);
                const curImg = await loadImageAsync(curImage);

                // Cr√©er les canvas
                const width = refImg.width;
                const height = refImg.height;

                const refCanvas = createCanvas(width, height);
                const curCanvas = createCanvas(width, height);

                const refCtx = refCanvas.getContext('2d');
                const curCtx = curCanvas.getContext('2d');

                refCtx.drawImage(refImg, 0, 0);
                curCtx.drawImage(curImg, 0, 0, width, height);

                // Obtenir les donn√©es des pixels
                const refData = refCtx.getImageData(0, 0, width, height);
                const curData = curCtx.getImageData(0, 0, width, height);

                // Cr√©er le masque de diff√©rence
                const diffMask = createDiffMask(refData, curData, width, height, threshold);

                // Nettoyer le masque (morphologie)
                const cleanedMask = cleanMask(diffMask, width, height, minSizeLevel);

                // Trouver les zones connexes (outils manquants)
                const regions = findRegions(cleanedMask, width, height, minArea);

                // Filtrer les r√©gions qui ressemblent √† des outils (pas des trous)
                const toolRegions = filterToolRegions(regions, width, height);

                // Afficher les r√©sultats
                displayResults(toolRegions, refImg, curImg, width, height, cleanedMask);

            } catch (error) {
                console.error('Erreur:', error);
                alert('Erreur: ' + error.message);
            }

            els.loading.classList.remove('visible');
        }

        function loadImageAsync(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function createCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        }

        function createDiffMask(refData, curData, width, height, threshold) {
            const mask = new Uint8Array(width * height);
            const refPx = refData.data;
            const curPx = curData.data;

            for (let i = 0; i < width * height; i++) {
                const idx = i * 4;

                // Convertir en niveaux de gris
                const refGray = (refPx[idx] * 0.299 + refPx[idx+1] * 0.587 + refPx[idx+2] * 0.114);
                const curGray = (curPx[idx] * 0.299 + curPx[idx+1] * 0.587 + curPx[idx+2] * 0.114);

                // Diff√©rence
                const diff = Math.abs(refGray - curGray);

                // Aussi v√©rifier la diff√©rence de couleur
                const rDiff = Math.abs(refPx[idx] - curPx[idx]);
                const gDiff = Math.abs(refPx[idx+1] - curPx[idx+1]);
                const bDiff = Math.abs(refPx[idx+2] - curPx[idx+2]);
                const colorDiff = Math.max(rDiff, gDiff, bDiff);

                // Combiner les deux crit√®res
                if (diff > threshold || colorDiff > threshold * 1.2) {
                    mask[i] = 255;
                }
            }

            return mask;
        }

        function cleanMask(mask, width, height, sizeLevel) {
            let result = new Uint8Array(mask);

            // Taille du kernel bas√©e sur le niveau
            const kernelSizes = [3, 5, 7, 9, 11];
            const kernelSize = kernelSizes[sizeLevel - 1];
            const half = Math.floor(kernelSize / 2);

            // √ârosion (supprime les petits points = trous du panneau)
            let eroded = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let allWhite = true;
                    for (let ky = -half; ky <= half && allWhite; ky++) {
                        for (let kx = -half; kx <= half && allWhite; kx++) {
                            if (result[(y + ky) * width + (x + kx)] === 0) {
                                allWhite = false;
                            }
                        }
                    }
                    eroded[y * width + x] = allWhite ? 255 : 0;
                }
            }

            // Dilatation (restaure les zones restantes)
            let dilated = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let anyWhite = false;
                    for (let ky = -half; ky <= half && !anyWhite; ky++) {
                        for (let kx = -half; kx <= half && !anyWhite; kx++) {
                            if (eroded[(y + ky) * width + (x + kx)] === 255) {
                                anyWhite = true;
                            }
                        }
                    }
                    dilated[y * width + x] = anyWhite ? 255 : 0;
                }
            }

            // Deuxi√®me dilatation pour agrandir les zones d√©tect√©es
            result = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let anyWhite = false;
                    for (let ky = -half; ky <= half && !anyWhite; ky++) {
                        for (let kx = -half; kx <= half && !anyWhite; kx++) {
                            if (dilated[(y + ky) * width + (x + kx)] === 255) {
                                anyWhite = true;
                            }
                        }
                    }
                    result[y * width + x] = anyWhite ? 255 : 0;
                }
            }

            return result;
        }

        function findRegions(mask, width, height, minArea) {
            const visited = new Uint8Array(width * height);
            const regions = [];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (mask[idx] === 255 && !visited[idx]) {
                        // BFS pour trouver la r√©gion connect√©e
                        const region = {
                            pixels: [],
                            minX: x, maxX: x,
                            minY: y, maxY: y
                        };

                        const queue = [{x, y}];
                        visited[idx] = 1;

                        while (queue.length > 0) {
                            const p = queue.shift();
                            region.pixels.push(p);
                            region.minX = Math.min(region.minX, p.x);
                            region.maxX = Math.max(region.maxX, p.x);
                            region.minY = Math.min(region.minY, p.y);
                            region.maxY = Math.max(region.maxY, p.y);

                            // Voisins 4-connect√©s
                            const neighbors = [
                                {x: p.x - 1, y: p.y},
                                {x: p.x + 1, y: p.y},
                                {x: p.x, y: p.y - 1},
                                {x: p.x, y: p.y + 1}
                            ];

                            for (const n of neighbors) {
                                if (n.x >= 0 && n.x < width && n.y >= 0 && n.y < height) {
                                    const nIdx = n.y * width + n.x;
                                    if (mask[nIdx] === 255 && !visited[nIdx]) {
                                        visited[nIdx] = 1;
                                        queue.push(n);
                                    }
                                }
                            }
                        }

                        region.area = region.pixels.length;
                        region.width = region.maxX - region.minX + 1;
                        region.height = region.maxY - region.minY + 1;
                        region.boundingBox = {
                            x: region.minX,
                            y: region.minY,
                            width: region.width,
                            height: region.height
                        };

                        // Filtrer par taille minimum
                        if (region.area >= minArea) {
                            regions.push(region);
                        }
                    }
                }
            }

            return regions;
        }

        function filterToolRegions(regions, imgWidth, imgHeight) {
            return regions.filter(region => {
                const box = region.boundingBox;

                // Ratio de la bo√Æte englobante (√©vite les formes trop allong√©es ou trop carr√©es/petites)
                const aspectRatio = Math.max(box.width, box.height) / (Math.min(box.width, box.height) + 1);

                // Les outils ont g√©n√©ralement un ratio entre 1 et 15
                if (aspectRatio > 20) return false;

                // Ratio de remplissage (aire / bo√Æte englobante)
                const fillRatio = region.area / (box.width * box.height);

                // Les trous du panneau ont souvent un faible ratio de remplissage apr√®s √©rosion
                // Les outils ont g√©n√©ralement un ratio > 0.2
                if (fillRatio < 0.15) return false;

                // Taille minimum relative √† l'image
                const relativeArea = region.area / (imgWidth * imgHeight);
                if (relativeArea < 0.0005) return false; // Moins de 0.05% de l'image

                // Taille maximum (√©vite de d√©tecter tout le fond)
                if (relativeArea > 0.3) return false; // Plus de 30% de l'image

                // Dimensions minimum absolues
                if (box.width < 20 || box.height < 20) return false;

                return true;
            });
        }

        function displayResults(regions, refImg, curImg, width, height, mask) {
            const count = regions.length;

            // R√©sum√©
            els.missingCount.textContent = count;
            els.summary.className = 'summary-card';

            if (count === 0) {
                els.summary.classList.add('success');
                els.summaryIcon.textContent = '‚úÖ';
            } else if (count <= 3) {
                els.summary.classList.add('warning');
                els.summaryIcon.textContent = '‚ö†Ô∏è';
            } else {
                els.summary.classList.add('danger');
                els.summaryIcon.textContent = 'üö®';
            }

            // Image r√©sultat
            els.resultCanvas.width = width;
            els.resultCanvas.height = height;
            const ctx = els.resultCanvas.getContext('2d');
            ctx.drawImage(refImg, 0, 0);

            // Dessiner les zones manquantes
            regions.forEach((region, index) => {
                const box = region.boundingBox;

                // Fond semi-transparent rouge
                ctx.fillStyle = 'rgba(239, 68, 68, 0.35)';
                ctx.fillRect(box.x, box.y, box.width, box.height);

                // Bordure rouge
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 3;
                ctx.strokeRect(box.x, box.y, box.width, box.height);

                // Num√©ro
                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 18px sans-serif';
                ctx.fillText(`${index + 1}`, box.x + 5, box.y + 22);
            });

            // Image de diff√©rence
            els.diffCanvas.width = width;
            els.diffCanvas.height = height;
            const diffCtx = els.diffCanvas.getContext('2d');
            const diffImageData = diffCtx.createImageData(width, height);

            for (let i = 0; i < mask.length; i++) {
                const idx = i * 4;
                if (mask[i] === 255) {
                    diffImageData.data[idx] = 255;     // R
                    diffImageData.data[idx + 1] = 100; // G
                    diffImageData.data[idx + 2] = 100; // B
                    diffImageData.data[idx + 3] = 255; // A
                } else {
                    diffImageData.data[idx] = 50;
                    diffImageData.data[idx + 1] = 50;
                    diffImageData.data[idx + 2] = 50;
                    diffImageData.data[idx + 3] = 255;
                }
            }
            diffCtx.putImageData(diffImageData, 0, 0);

            // Comparaison
            els.compareRef.src = refImage;
            els.compareCur.src = curImage;

            // Afficher
            els.resultsSection.classList.add('visible');
            els.resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        // Initialisation
        setupDropZone(els.refDrop, els.refInput, els.refPreview, els.clearRef, true);
        setupDropZone(els.curDrop, els.curInput, els.curPreview, els.clearCur, false);
    </script>
</body>
</html>
