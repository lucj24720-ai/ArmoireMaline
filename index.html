<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#6366f1">
    <title>ArmoireMaline - D√©tection d'outils manquants</title>
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --primary: #6366f1;
            --primary-hover: #4f46e5;
            --primary-light: #e0e7ff;
            --success: #10b981;
            --success-light: #d1fae5;
            --warning: #f59e0b;
            --warning-light: #fef3c7;
            --danger: #ef4444;
            --danger-light: #fee2e2;
            --bg: #f0f4ff;
            --surface: #ffffff;
            --text: #1e293b;
            --text-light: #64748b;
            --border: #c7d2fe;
            --gradient-start: #6366f1;
            --gradient-end: #8b5cf6;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg) 0%, #e0e7ff 100%);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
            position: relative;
        }

        /* Fond avec outils - plusieurs couches */
        body::before,
        body::after {
            position: fixed;
            pointer-events: none;
            z-index: 0;
        }

        body::before {
            content: "üîß";
            top: 5%;
            left: 10%;
            font-size: 80px;
            opacity: 0.25;
            transform: rotate(-15deg);
        }

        body::after {
            content: "üî®";
            top: 15%;
            right: 8%;
            font-size: 70px;
            opacity: 0.25;
            transform: rotate(20deg);
        }

        /* Outils suppl√©mentaires via √©l√©ments HTML - dispers√©s partout */
        .tool-bg {
            position: fixed;
            pointer-events: none;
            z-index: 0;
            opacity: 0.35;
            font-size: 60px;
        }

        .tool-1 { top: 3%; left: 5%; transform: rotate(-15deg); }
        .tool-2 { top: 8%; left: 35%; transform: rotate(25deg); }
        .tool-3 { top: 5%; right: 15%; transform: rotate(-30deg); }
        .tool-4 { top: 12%; right: 3%; transform: rotate(10deg); }
        .tool-5 { top: 22%; left: 8%; transform: rotate(35deg); }
        .tool-6 { top: 28%; left: 45%; transform: rotate(-20deg); font-size: 55px; }
        .tool-7 { top: 18%; right: 25%; transform: rotate(40deg); }
        .tool-8 { top: 35%; left: 2%; transform: rotate(-25deg); }
        .tool-9 { top: 40%; right: 5%; transform: rotate(15deg); font-size: 65px; }
        .tool-10 { top: 32%; left: 70%; transform: rotate(-35deg); }
        .tool-11 { top: 48%; left: 15%; transform: rotate(20deg); }
        .tool-12 { top: 52%; left: 55%; transform: rotate(-10deg); font-size: 50px; }
        .tool-13 { top: 45%; right: 20%; transform: rotate(30deg); }
        .tool-14 { top: 58%; left: 3%; transform: rotate(-40deg); }
        .tool-15 { top: 62%; right: 8%; transform: rotate(5deg); font-size: 70px; }
        .tool-16 { top: 55%; left: 35%; transform: rotate(-15deg); }
        .tool-17 { top: 68%; left: 10%; transform: rotate(25deg); }
        .tool-18 { top: 72%; left: 50%; transform: rotate(-30deg); font-size: 55px; }
        .tool-19 { top: 65%; right: 30%; transform: rotate(35deg); }
        .tool-20 { top: 78%; left: 5%; transform: rotate(-20deg); }
        .tool-21 { top: 75%; right: 5%; transform: rotate(10deg); }
        .tool-22 { top: 82%; left: 40%; transform: rotate(-25deg); font-size: 65px; }
        .tool-23 { top: 85%; left: 70%; transform: rotate(40deg); }
        .tool-24 { top: 88%; left: 20%; transform: rotate(-35deg); }
        .tool-25 { top: 92%; right: 15%; transform: rotate(15deg); font-size: 50px; }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            border-radius: 0 0 30px 30px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);
        }

        header h1 {
            font-size: 2.2rem;
            color: white;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .subtitle { color: rgba(255,255,255,0.9); font-size: 1rem; }

        /* Cards */
        .card {
            background: var(--surface);
            border-radius: 20px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.1);
            margin-bottom: 24px;
            border: 1px solid var(--border);
        }

        .card h3 {
            margin-bottom: 12px;
            color: var(--primary);
        }
        .card .desc { color: var(--text-light); font-size: 0.9rem; margin-bottom: 16px; }

        .hidden { display: none !important; }

        /* Upload grid */
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Drop zone */
        .drop-zone {
            border: 2px dashed var(--primary);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background: linear-gradient(135deg, var(--primary-light) 0%, #f5f3ff 100%);
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--primary-hover);
            background: linear-gradient(135deg, #c7d2fe 0%, #e0e7ff 100%);
            transform: scale(1.02);
        }

        .drop-zone.has-image {
            padding: 10px;
        }

        .drop-zone.has-image .drop-content { display: none; }

        .drop-zone img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            display: none;
        }

        .drop-zone.has-image img { display: block; }

        .drop-icon { font-size: 2.5rem; margin-bottom: 8px; }

        .clear-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: none;
            font-size: 1.2rem;
            line-height: 1;
        }

        .drop-zone.has-image .clear-btn { display: block; }

        .upload-buttons {
            display: flex;
            gap: 10px;
            margin-top: 12px;
        }

        .upload-btn {
            padding: 10px 16px;
            border: none;
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: white;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        /* Options */
        .options-section {
            background: var(--bg);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .options-section summary {
            cursor: pointer;
            font-weight: 600;
            padding: 4px 0;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            padding-top: 16px;
        }

        .option-group label {
            font-weight: 500;
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .option-group input[type="range"] { width: 100%; }

        .option-value {
            font-size: 0.85rem;
            color: var(--primary);
            font-weight: 600;
        }

        /* Buttons */
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, var(--primary-hover) 0%, #7c3aed 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.5);
        }

        .btn-primary:disabled {
            background: var(--text-light);
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .analyze-container {
            text-align: center;
            margin: 24px 0;
        }

        /* Results */
        .results-section {
            display: none;
        }

        .results-section.visible { display: block; }

        .summary-card {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .summary-card.success {
            background: linear-gradient(135deg, var(--success-light) 0%, #ecfdf5 100%);
            border: 2px solid var(--success);
        }
        .summary-card.warning {
            background: linear-gradient(135deg, var(--warning-light) 0%, #fffbeb 100%);
            border: 2px solid var(--warning);
        }
        .summary-card.danger {
            background: linear-gradient(135deg, var(--danger-light) 0%, #fef2f2 100%);
            border: 2px solid var(--danger);
        }

        .summary-icon { font-size: 3rem; }
        .summary-count { text-align: center; }
        .missing-count { font-size: 2.5rem; font-weight: 700; display: block; }
        .missing-label { color: var(--text-light); }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 8px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.95rem;
            color: var(--text-light);
            border-radius: 8px 8px 0 0;
        }

        .tab:hover { color: var(--text); background: var(--bg); }
        .tab.active { color: var(--primary); background: rgba(37, 99, 235, 0.1); font-weight: 600; }

        .tab-pane { display: none; }
        .tab-pane.active { display: block; }

        .result-image {
            max-width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }

        .result-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .result-item {
            text-align: center;
        }

        .result-label {
            display: block;
            margin-bottom: 12px;
            font-weight: 600;
            font-size: 1rem;
            color: var(--text);
        }

        .result-item canvas {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }

        /* Info box */
        .info-box {
            background: rgba(37, 99, 235, 0.1);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            font-size: 0.9rem;
        }

        .info-box strong { color: var(--primary); }

        /* Loading */
        .loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading.visible { display: flex; }

        .spinner {
            width: 60px; height: 60px;
            border: 5px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading p { margin-top: 20px; color: var(--text-light); font-size: 1.1rem; }

        footer {
            text-align: center;
            padding: 24px;
            color: var(--text-light);
            font-size: 0.85rem;
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            border-radius: 30px 30px 0 0;
            margin-top: 20px;
        }

        footer p {
            color: rgba(255,255,255,0.9);
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 { font-size: 1.6rem; }
            .upload-grid { grid-template-columns: 1fr; }
            .result-comparison { grid-template-columns: 1fr; }
            .btn { padding: 12px 20px; font-size: 1rem; width: 100%; }
            .options-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <!-- Outils en fond dispers√©s partout -->
    <div class="tool-bg tool-1">üîß</div>
    <div class="tool-bg tool-2">üî®</div>
    <div class="tool-bg tool-3">ü™õ</div>
    <div class="tool-bg tool-4">üî©</div>
    <div class="tool-bg tool-5">ü™ö</div>
    <div class="tool-bg tool-6">üîß</div>
    <div class="tool-bg tool-7">üî®</div>
    <div class="tool-bg tool-8">ü™õ</div>
    <div class="tool-bg tool-9">üî©</div>
    <div class="tool-bg tool-10">ü™ö</div>
    <div class="tool-bg tool-11">üîß</div>
    <div class="tool-bg tool-12">üî®</div>
    <div class="tool-bg tool-13">ü™õ</div>
    <div class="tool-bg tool-14">üî©</div>
    <div class="tool-bg tool-15">ü™ö</div>
    <div class="tool-bg tool-16">üîß</div>
    <div class="tool-bg tool-17">üî®</div>
    <div class="tool-bg tool-18">ü™õ</div>
    <div class="tool-bg tool-19">üî©</div>
    <div class="tool-bg tool-20">ü™ö</div>
    <div class="tool-bg tool-21">üîß</div>
    <div class="tool-bg tool-22">üî®</div>
    <div class="tool-bg tool-23">ü™õ</div>
    <div class="tool-bg tool-24">üî©</div>
    <div class="tool-bg tool-25">ü™ö</div>

    <div class="container">
        <header>
            <h1>üîß ArmoireMaline</h1>
            <p class="subtitle">D√©tection automatique d'outils manquants</p>
        </header>

        <main>
            <!-- Upload Section -->
            <div class="card">
                <div class="info-box">
                    <strong>Comment √ßa marche :</strong> L'application d√©tecte les outils sur la photo de r√©f√©rence,
                    puis v√©rifie s'ils sont toujours pr√©sents sur la photo actuelle.
                </div>

                <div class="upload-grid">
                    <!-- R√©f√©rence -->
                    <div>
                        <h3>üì∏ Photo de r√©f√©rence</h3>
                        <p class="desc">Armoire compl√®te (tous les outils)</p>
                        <div class="drop-zone" id="refDrop">
                            <input type="file" id="refInputGallery" accept="image/*" hidden>
                            <input type="file" id="refInputCamera" accept="image/*" capture="environment" hidden>
                            <div class="drop-content">
                                <span class="drop-icon">üìÅ</span>
                                <p>Glissez une image ici</p>
                                <div class="upload-buttons">
                                    <button type="button" class="upload-btn" id="refGalleryBtn">üñºÔ∏è Galerie</button>
                                    <button type="button" class="upload-btn" id="refCameraBtn">üì∑ Photo</button>
                                </div>
                            </div>
                            <img id="refPreview" alt="R√©f√©rence">
                            <button class="clear-btn" id="clearRef">√ó</button>
                        </div>
                    </div>

                    <!-- Actuelle -->
                    <div>
                        <h3>üì∑ Photo actuelle</h3>
                        <p class="desc">Armoire √† v√©rifier</p>
                        <div class="drop-zone" id="curDrop">
                            <input type="file" id="curInputGallery" accept="image/*" hidden>
                            <input type="file" id="curInputCamera" accept="image/*" capture="environment" hidden>
                            <div class="drop-content">
                                <span class="drop-icon">üìÅ</span>
                                <p>Glissez une image ici</p>
                                <div class="upload-buttons">
                                    <button type="button" class="upload-btn" id="curGalleryBtn">üñºÔ∏è Galerie</button>
                                    <button type="button" class="upload-btn" id="curCameraBtn">üì∑ Photo</button>
                                </div>
                            </div>
                            <img id="curPreview" alt="Actuelle">
                            <button class="clear-btn" id="clearCur">√ó</button>
                        </div>
                    </div>
                </div>

                <!-- Options -->
                <details class="options-section" open>
                    <summary>‚öôÔ∏è Options de d√©tection</summary>
                    <div class="options-grid">
                        <div class="option-group">
                            <label>Sensibilit√© : <span class="option-value" id="sensitivityVal">Moyenne</span></label>
                            <input type="range" id="sensitivity" min="1" max="5" value="3">
                        </div>
                        <div class="option-group">
                            <label>Taille min des outils : <span class="option-value" id="minSizeVal">Moyenne</span></label>
                            <input type="range" id="minSize" min="1" max="5" value="3">
                        </div>
                    </div>
                </details>

                <div class="analyze-container">
                    <button class="btn btn-primary" id="analyzeBtn" disabled>
                        üîç Analyser les diff√©rences
                    </button>
                </div>
            </div>

            <!-- Results Section -->
            <section class="card results-section" id="resultsSection">
                <h3>üìä R√©sultats de l'analyse</h3>

                <div class="summary-card" id="summary">
                    <div class="summary-icon" id="summaryIcon">‚úÖ</div>
                    <div class="summary-count">
                        <span class="missing-count" id="missingCount">0</span>
                        <span class="missing-label">outil(s) manquant(s) sur <span id="totalTools">0</span> d√©tect√©(s)</span>
                    </div>
                </div>

                <div class="result-comparison">
                    <div class="result-item">
                        <span class="result-label">üì∏ R√©f√©rence (outils d√©tect√©s)</span>
                        <canvas id="refToolsCanvas" class="result-image"></canvas>
                    </div>
                    <div class="result-item">
                        <span class="result-label">üì∑ Actuelle (outils manquants en rouge)</span>
                        <canvas id="resultCanvas" class="result-image"></canvas>
                    </div>
                </div>
            </section>
        </main>

        <footer>
            <p>ArmoireMaline v3.0 - D√©tection intelligente d'outils manquants</p>
        </footer>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p id="loadingText">Analyse en cours...</p>
    </div>

    <script>
        // √âtat
        let refImage = null;
        let curImage = null;

        // √âl√©ments DOM
        const els = {
            refDrop: document.getElementById('refDrop'),
            curDrop: document.getElementById('curDrop'),
            refInputGallery: document.getElementById('refInputGallery'),
            refInputCamera: document.getElementById('refInputCamera'),
            curInputGallery: document.getElementById('curInputGallery'),
            curInputCamera: document.getElementById('curInputCamera'),
            refGalleryBtn: document.getElementById('refGalleryBtn'),
            refCameraBtn: document.getElementById('refCameraBtn'),
            curGalleryBtn: document.getElementById('curGalleryBtn'),
            curCameraBtn: document.getElementById('curCameraBtn'),
            refPreview: document.getElementById('refPreview'),
            curPreview: document.getElementById('curPreview'),
            clearRef: document.getElementById('clearRef'),
            clearCur: document.getElementById('clearCur'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            sensitivity: document.getElementById('sensitivity'),
            sensitivityVal: document.getElementById('sensitivityVal'),
            minSize: document.getElementById('minSize'),
            minSizeVal: document.getElementById('minSizeVal'),
            resultsSection: document.getElementById('resultsSection'),
            summary: document.getElementById('summary'),
            summaryIcon: document.getElementById('summaryIcon'),
            missingCount: document.getElementById('missingCount'),
            totalTools: document.getElementById('totalTools'),
            resultCanvas: document.getElementById('resultCanvas'),
            refToolsCanvas: document.getElementById('refToolsCanvas'),
            loading: document.getElementById('loading'),
            loadingText: document.getElementById('loadingText')
        };

        // Setup drop zones avec boutons s√©par√©s
        function setupDropZone(dropEl, galleryInput, cameraInput, galleryBtn, cameraBtn, previewEl, clearBtn, isRef) {
            // Bouton galerie
            galleryBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                galleryInput.click();
            });

            // Bouton cam√©ra
            cameraBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                cameraInput.click();
            });

            // Drag & drop
            dropEl.addEventListener('dragover', e => {
                e.preventDefault();
                dropEl.classList.add('dragover');
            });

            dropEl.addEventListener('dragleave', () => dropEl.classList.remove('dragover'));

            dropEl.addEventListener('drop', e => {
                e.preventDefault();
                dropEl.classList.remove('dragover');
                if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0], previewEl, dropEl, isRef);
            });

            // Input change (galerie)
            galleryInput.addEventListener('change', e => {
                if (e.target.files[0]) loadImage(e.target.files[0], previewEl, dropEl, isRef);
            });

            // Input change (cam√©ra)
            cameraInput.addEventListener('change', e => {
                if (e.target.files[0]) loadImage(e.target.files[0], previewEl, dropEl, isRef);
            });

            // Bouton clear
            clearBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                previewEl.src = '';
                dropEl.classList.remove('has-image');
                galleryInput.value = '';
                cameraInput.value = '';
                if (isRef) refImage = null;
                else curImage = null;
                updateAnalyzeBtn();
                els.resultsSection.classList.remove('visible');
            });
        }

        function loadImage(file, previewEl, dropEl, isRef) {
            const reader = new FileReader();
            reader.onload = e => {
                previewEl.src = e.target.result;
                dropEl.classList.add('has-image');
                if (isRef) refImage = e.target.result;
                else curImage = e.target.result;
                updateAnalyzeBtn();
            };
            reader.readAsDataURL(file);
        }

        function updateAnalyzeBtn() {
            els.analyzeBtn.disabled = !(refImage && curImage);
        }

        // Options labels
        const sensitivityLabels = ['Tr√®s basse', 'Basse', 'Moyenne', 'Haute', 'Tr√®s haute'];
        const minSizeLabels = ['Tr√®s petit', 'Petit', 'Moyen', 'Grand', 'Tr√®s grand'];

        els.sensitivity.addEventListener('input', e => {
            els.sensitivityVal.textContent = sensitivityLabels[e.target.value - 1];
        });

        els.minSize.addEventListener('input', e => {
            els.minSizeVal.textContent = minSizeLabels[e.target.value - 1];
        });

        // Tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
            });
        });

        // Analyze
        els.analyzeBtn.addEventListener('click', analyze);

        async function analyze() {
            els.loading.classList.add('visible');
            els.loadingText.textContent = 'Chargement des images...';
            await sleep(50);

            try {
                const sensitivityLevel = parseInt(els.sensitivity.value);
                const minSizeLevel = parseInt(els.minSize.value);

                // Charger les images
                const refImg = await loadImageAsync(refImage);
                const curImg = await loadImageAsync(curImage);

                const width = refImg.width;
                const height = refImg.height;

                // Cr√©er les canvas
                const refCanvas = createCanvas(width, height);
                const curCanvas = createCanvas(width, height);

                const refCtx = refCanvas.getContext('2d');
                const curCtx = curCanvas.getContext('2d');

                refCtx.drawImage(refImg, 0, 0);
                curCtx.drawImage(curImg, 0, 0, width, height);

                const refData = refCtx.getImageData(0, 0, width, height);
                const curData = curCtx.getImageData(0, 0, width, height);

                // √âTAPE 1: D√©tecter le fond (panneau perfor√© bleu)
                els.loadingText.textContent = 'D√©tection du fond...';
                await sleep(50);
                const { mask: backgroundMask, bgColors } = detectBackground(refData, width, height);

                // √âTAPE 2: D√©tecter les outils sur l'image de r√©f√©rence (tout ce qui n'est pas le fond)
                els.loadingText.textContent = 'D√©tection des outils...';
                await sleep(50);
                const toolsMask = detectTools(refData, backgroundMask, width, height);

                // √âTAPE 3: Nettoyer et trouver les r√©gions d'outils
                const minAreas = [300, 600, 1200, 2500, 5000]; // Valeurs r√©duites pour d√©tecter plus d'outils
                const minArea = minAreas[minSizeLevel - 1];

                const cleanedMask = cleanToolsMask(toolsMask, width, height, minSizeLevel);
                const toolRegions = findToolRegions(cleanedMask, width, height, minArea);

                // √âTAPE 4: V√©rifier quels outils sont manquants
                els.loadingText.textContent = 'V√©rification des outils manquants...';
                await sleep(50);

                const thresholds = [10, 18, 28, 40, 55]; // Seuils plus bas pour √™tre plus sensible
                const threshold = thresholds[sensitivityLevel - 1];

                const results = checkMissingTools(toolRegions, refData, curData, width, height, threshold, bgColors);

                // Afficher les r√©sultats
                displayResults(results, refImg, curImg, width, height, toolRegions);

            } catch (error) {
                console.error('Erreur:', error);
                alert('Erreur: ' + error.message);
            }

            els.loading.classList.remove('visible');
        }

        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        function loadImageAsync(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function createCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        }

        // D√©tecter le fond et les √©l√©ments neutres (gris/blanc/beige)
        function detectBackground(imageData, width, height) {
            const data = imageData.data;
            const mask = new Uint8Array(width * height);
            const bgColors = [];

            // Marquer comme fond : gris, blanc, beige, et couleurs peu satur√©es
            for (let i = 0; i < width * height; i++) {
                const idx = i * 4;
                const r = data[idx];
                const g = data[idx + 1];
                const b = data[idx + 2];

                // Calculer la saturation (diff√©rence entre max et min des canaux)
                const maxC = Math.max(r, g, b);
                const minC = Math.min(r, g, b);
                const saturation = maxC - minC;

                // Luminosit√© moyenne
                const brightness = (r + g + b) / 3;

                // Un pixel est consid√©r√© comme "fond/structure" si :
                // - Faible saturation (gris, blanc, beige) = pas un outil color√©
                // - OU tr√®s clair (blanc, reflets)
                // - OU tr√®s sombre (ombres)
                const isNeutral = saturation < 40; // Peu de couleur
                const isVeryBright = brightness > 220;
                const isVeryDark = brightness < 30;

                mask[i] = (isNeutral || isVeryBright || isVeryDark) ? 255 : 0;
            }

            // Collecter quelques couleurs de fond typiques pour la comparaison
            bgColors.push({ r: 180, g: 180, b: 180 }); // Gris clair
            bgColors.push({ r: 150, g: 150, b: 150 }); // Gris moyen
            bgColors.push({ r: 200, g: 200, b: 200 }); // Gris tr√®s clair
            bgColors.push({ r: 220, g: 220, b: 220 }); // Presque blanc

            return { mask, bgColors };
        }

        // D√©tecter les outils (pixels qui ne sont pas le fond)
        function detectTools(imageData, backgroundMask, width, height) {
            const mask = new Uint8Array(width * height);

            for (let i = 0; i < width * height; i++) {
                // Un outil = pas le fond
                mask[i] = backgroundMask[i] === 0 ? 255 : 0;
            }

            return mask;
        }

        // Nettoyer le masque des outils
        function cleanToolsMask(mask, width, height, sizeLevel) {
            // Taille du kernel pour l'√©rosion/dilatation
            const kernelSizes = [2, 3, 4, 5, 6];
            const kernelSize = kernelSizes[sizeLevel - 1];
            const half = kernelSize;

            // √ârosion forte pour supprimer le bruit et les petits √©l√©ments
            let eroded = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let count = 0;
                    let total = 0;
                    for (let ky = -half; ky <= half; ky++) {
                        for (let kx = -half; kx <= half; kx++) {
                            total++;
                            if (mask[(y + ky) * width + (x + kx)] === 255) {
                                count++;
                            }
                        }
                    }
                    // Au moins 70% des pixels doivent √™tre blancs
                    eroded[y * width + x] = (count / total > 0.7) ? 255 : 0;
                }
            }

            // Dilatation pour restaurer la taille
            let dilated = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let anyWhite = false;
                    for (let ky = -half; ky <= half && !anyWhite; ky++) {
                        for (let kx = -half; kx <= half && !anyWhite; kx++) {
                            if (eroded[(y + ky) * width + (x + kx)] === 255) {
                                anyWhite = true;
                            }
                        }
                    }
                    dilated[y * width + x] = anyWhite ? 255 : 0;
                }
            }

            // Deuxi√®me dilatation
            let result = new Uint8Array(width * height);
            for (let y = half; y < height - half; y++) {
                for (let x = half; x < width - half; x++) {
                    let anyWhite = false;
                    for (let ky = -half; ky <= half && !anyWhite; ky++) {
                        for (let kx = -half; kx <= half && !anyWhite; kx++) {
                            if (dilated[(y + ky) * width + (x + kx)] === 255) {
                                anyWhite = true;
                            }
                        }
                    }
                    result[y * width + x] = anyWhite ? 255 : 0;
                }
            }

            return result;
        }

        // Trouver les r√©gions d'outils
        function findToolRegions(mask, width, height, minArea) {
            const visited = new Uint8Array(width * height);
            const regions = [];

            // Calculer la taille minimale pour exclure les trous du panneau
            // Les trous sont g√©n√©ralement petits et circulaires
            const minDimension = 25; // Taille minimale pour un outil
            const maxHoleArea = 1500; // Les trous sont plus petits que √ßa

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (mask[idx] === 255 && !visited[idx]) {
                        const region = floodFill(mask, visited, x, y, width, height);
                        const box = region.boundingBox;

                        // Filtrer les petits trous du panneau perfor√©
                        // Les trous sont g√©n√©ralement circulaires (ratio proche de 1) et petits
                        const aspectRatio = Math.max(box.width, box.height) / (Math.min(box.width, box.height) + 1);
                        const fillRatio = region.area / (box.width * box.height);
                        const isCircular = aspectRatio < 1.8 && fillRatio > 0.5;
                        const isSmallHole = region.area < maxHoleArea && isCircular;

                        // Un outil doit √™tre assez grand et pas un petit trou circulaire
                        if (region.area >= minArea && !isSmallHole) {
                            // V√©rifier que c'est bien un outil (pas trop petit)
                            if (box.width >= minDimension || box.height >= minDimension) {
                                // Filtrer les formes trop fines ou √©tranges
                                if (aspectRatio < 20 && fillRatio > 0.08) {
                                    regions.push(region);
                                }
                            }
                        }
                    }
                }
            }

            return regions;
        }

        function floodFill(mask, visited, startX, startY, width, height) {
            const region = {
                pixels: [],
                minX: startX, maxX: startX,
                minY: startY, maxY: startY,
                area: 0
            };

            const queue = [{x: startX, y: startY}];
            visited[startY * width + startX] = 1;

            while (queue.length > 0) {
                const p = queue.shift();
                region.pixels.push(p);
                region.minX = Math.min(region.minX, p.x);
                region.maxX = Math.max(region.maxX, p.x);
                region.minY = Math.min(region.minY, p.y);
                region.maxY = Math.max(region.maxY, p.y);

                const neighbors = [
                    {x: p.x - 1, y: p.y},
                    {x: p.x + 1, y: p.y},
                    {x: p.x, y: p.y - 1},
                    {x: p.x, y: p.y + 1}
                ];

                for (const n of neighbors) {
                    if (n.x >= 0 && n.x < width && n.y >= 0 && n.y < height) {
                        const nIdx = n.y * width + n.x;
                        if (mask[nIdx] === 255 && !visited[nIdx]) {
                            visited[nIdx] = 1;
                            queue.push(n);
                        }
                    }
                }
            }

            region.area = region.pixels.length;
            region.boundingBox = {
                x: region.minX,
                y: region.minY,
                width: region.maxX - region.minX + 1,
                height: region.maxY - region.minY + 1
            };

            return region;
        }

        // V√©rifier quels outils sont manquants
        function checkMissingTools(toolRegions, refData, curData, width, height, threshold, bgColors) {
            const curPx = curData.data;
            const results = [];

            // Pour chaque outil d√©tect√© dans la r√©f√©rence
            for (const region of toolRegions) {
                const box = region.boundingBox;

                // √âlargir la zone de recherche pour tol√©rer les d√©calages
                const margin = 30; // Marge de 30 pixels autour de l'outil
                const searchX1 = Math.max(0, box.x - margin);
                const searchY1 = Math.max(0, box.y - margin);
                const searchX2 = Math.min(width, box.x + box.width + margin);
                const searchY2 = Math.min(height, box.y + box.height + margin);

                // Compter les pixels color√©s dans cette zone √©largie de l'image actuelle
                let coloredPixelsInArea = 0;
                let totalPixelsChecked = 0;

                for (let y = searchY1; y < searchY2; y += 2) {
                    for (let x = searchX1; x < searchX2; x += 2) {
                        const idx = (y * width + x) * 4;
                        const r = curPx[idx];
                        const g = curPx[idx + 1];
                        const b = curPx[idx + 2];

                        totalPixelsChecked++;

                        // V√©rifier si c'est un pixel color√© (pas gris/blanc)
                        const sat = Math.max(r, g, b) - Math.min(r, g, b);
                        const brightness = (r + g + b) / 3;

                        // D√©tecter les couleurs typiques des outils
                        const isColored = sat > 30 && brightness > 35 && brightness < 235;

                        if (isColored) {
                            coloredPixelsInArea++;
                        }
                    }
                }

                // Calculer le ratio de pixels color√©s dans la zone
                const coloredRatio = totalPixelsChecked > 0 ? coloredPixelsInArea / totalPixelsChecked : 0;

                // Calculer la surface minimale attendue pour un outil pr√©sent
                // (bas√© sur la taille de l'outil dans la r√©f√©rence)
                const toolAreaRatio = region.area / ((searchX2 - searchX1) * (searchY2 - searchY1));
                const expectedMinRatio = toolAreaRatio * 0.3; // Au moins 30% de la taille originale

                // Un outil est MANQUANT seulement si :
                // - Il y a tr√®s peu de pixels color√©s dans la zone (< 5%)
                // - OU le ratio est bien en dessous de ce qu'on attendrait
                const isMissing = coloredRatio < 0.05 || coloredRatio < expectedMinRatio * 0.5;

                console.log(`Outil √† (${box.x}, ${box.y}): coloredRatio=${(coloredRatio * 100).toFixed(1)}%, expectedMin=${(expectedMinRatio * 100).toFixed(1)}%, missing=${isMissing}`);

                results.push({
                    region: region,
                    coloredRatio: coloredRatio,
                    isMissing: isMissing
                });
            }

            return results;
        }

        // Afficher les r√©sultats
        function displayResults(results, refImg, curImg, width, height, toolRegions) {
            const missingTools = results.filter(r => r.isMissing);
            const missingCount = missingTools.length;
            const totalTools = results.length;

            // R√©sum√©
            els.missingCount.textContent = missingCount;
            els.totalTools.textContent = totalTools;
            els.summary.className = 'summary-card';

            if (missingCount === 0) {
                els.summary.classList.add('success');
                els.summaryIcon.textContent = '‚úÖ';
            } else if (missingCount <= 3) {
                els.summary.classList.add('warning');
                els.summaryIcon.textContent = '‚ö†Ô∏è';
            } else {
                els.summary.classList.add('danger');
                els.summaryIcon.textContent = 'üö®';
            }

            // Image r√©sultat (photo actuelle avec outils manquants entour√©s)
            els.resultCanvas.width = width;
            els.resultCanvas.height = height;
            const ctx = els.resultCanvas.getContext('2d');
            ctx.drawImage(curImg, 0, 0, width, height);

            // Dessiner les outils manquants en rouge
            let missingIndex = 0;
            for (const result of results) {
                if (result.isMissing) {
                    missingIndex++;
                    const box = result.region.boundingBox;

                    // Fond semi-transparent rouge
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.4)';
                    ctx.fillRect(box.x, box.y, box.width, box.height);

                    // Bordure rouge √©paisse
                    ctx.strokeStyle = '#dc2626';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);

                    // Num√©ro
                    ctx.fillStyle = '#dc2626';
                    ctx.font = 'bold 24px sans-serif';
                    ctx.fillText(`${missingIndex}`, box.x + 8, box.y + 28);
                }
            }

            // Image avec tous les outils d√©tect√©s sur la r√©f√©rence
            els.refToolsCanvas.width = width;
            els.refToolsCanvas.height = height;
            const refCtx = els.refToolsCanvas.getContext('2d');
            refCtx.drawImage(refImg, 0, 0);

            // Dessiner tous les outils d√©tect√©s
            results.forEach((result, index) => {
                const box = result.region.boundingBox;

                if (result.isMissing) {
                    refCtx.strokeStyle = '#dc2626'; // Rouge pour manquant
                    refCtx.fillStyle = 'rgba(239, 68, 68, 0.3)';
                } else {
                    refCtx.strokeStyle = '#16a34a'; // Vert pour pr√©sent
                    refCtx.fillStyle = 'rgba(22, 163, 74, 0.2)';
                }

                refCtx.lineWidth = 3;
                refCtx.fillRect(box.x, box.y, box.width, box.height);
                refCtx.strokeRect(box.x, box.y, box.width, box.height);

                // Num√©ro
                refCtx.fillStyle = result.isMissing ? '#dc2626' : '#16a34a';
                refCtx.font = 'bold 16px sans-serif';
                refCtx.fillText(`${index + 1}`, box.x + 5, box.y + 18);
            });

            // Afficher
            els.resultsSection.classList.add('visible');
            els.resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        // Initialisation
        setupDropZone(els.refDrop, els.refInputGallery, els.refInputCamera, els.refGalleryBtn, els.refCameraBtn, els.refPreview, els.clearRef, true);
        setupDropZone(els.curDrop, els.curInputGallery, els.curInputCamera, els.curGalleryBtn, els.curCameraBtn, els.curPreview, els.clearCur, false);
    </script>
</body>
</html>
